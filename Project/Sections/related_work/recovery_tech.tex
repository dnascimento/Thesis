%!TEX encoding = UTF-8 Unicode
\subsection{Formalization of the Recovery Process}
\label{subSec:RecoveryModels}
As discussed in previous section, intrusion recovery services detect the intrusion effects, revert them and restore the application to a correct state. Here we explain this process by formally modeling the application as a sequence of actions and outline the distinct approaches to perform intrusion recovery. \\ 

An application execution is modeled as a set of actions $A$ and a set of objects $D$. Actions are described by a type (read, write, others more complex), the value(s) read/written, and a timestamp (which defines the order of the actions). Each object has a state or value and a set of operations that can modify it. We specify $A_{intrusion}$ as the subsequence of actions of $A$ whereby the attacker compromises the application during the intrusion, $A_{after}$ as the subsequence of actions that begins after the intrusion begin (including the first action of the intrusion) and $A_{legal}$ as the subsequence of legitimate actions in $A$. Notice that $A_{legal} = A - A_{intrusion}$. 

A recovery service aims to set the state of a service to $D_{recovered}$ at the end of the recovery process. The set $D_{recovered}$ shall be composed of objects as if their state was defined exclusively by a set of legitimate actions $A_{recovered}$. The objects of the subset $D_{recovered}$ represent a new \textit{intrusion-free} and \textit{consistent state}. A state is consistent if it is valid according to the application specification. A state is intrusion-free if it is created only by legitimate actions. If the application respects the specification (correctness), then changing from $D$ to $D_{recovered}$ performs service restoration \cite{Aviz}, i.e., restores the application service to a correct behavior.

A basic recovery service, like a full-backup mechanism, tries to obtain, after the recovery, the subset of object values $D_{recovered}$ written before the intrusion, which do not include the attacker actions, i.e., $D_{recovered} = D - D_{after} : D_{recovered} \cap D_{intrusion} = \emptyset$.

We define the set of \textit{tainted} actions, $A_{tainted}$, and the set of tainted objects, $D_{tainted}$, at a certain instant in the following way: if an action belongs to $A_{intrusion}$, then it belows to $A_{tainted}$; if an object belongs to $D_{intrusion}$ then it belongs to $D_{tainted}$; if an action in $A_{legal}$ reads an object in $D_{tainted}$, then that action belongs to $A_{tainted}$; if an action in $A_{tainted}$ writes an object value in $D_{legal}$, then that object belongs to $D_{tainted}$. Therefore, $A_{tainted}$ includes $A_{intrusion}$ but typically also actions from $A_{legal}$ that were corrupted by corrupted state. Also, $D_{tainted}$ includes $D_{intrusion}$ but typically also objects from $D_{legal}$ that were corrupted by corrupted state. Then, the set of object values written only by non-malicious actions is not the same as the set of objects obtained after removing the objects written by malicious or tainted actions, i.e., $D_{legal}$ written by $A \cap A_{intrusion} = \emptyset$ is not equal to $D_{legal}$ written by $D-D_{intrusion}$ or $D_{legal}$ written by $D-D_{tainted}$. In other words, to remove the objects written by intrusions and tainted actions is necessary but not enough to obtain the values of the set of objects that would be produced only by legitimate actions.

Some intrusion recovery systems \cite{taser,itdb,phoenix} attempt to obtain $D_{recovered}$ where the values of the objects of $D_{tainted}$ are removed from the current state $D$. To do so, the value of each object in $D_{tainted}$ is replaced by a previous value. These systems keep the objects written by legitimate actions, $D_{legal}$, unmodified. \\


Consider an hypothetical application execution at a certain point in time, after the intrusion, where $A$ is replaced by the set $A_{recovered} = A - A_{intrusion} = A_{legal}$, i.e., where the intrusion actions $A_{intrusion}$ are not executed. We would have in this application: $A \cap A_{intrusion} = \emptyset \implies D_{intrusion} = \emptyset, A_{tainted} = \emptyset \implies D_{tainted} = \emptyset$. In other words, if the malicious action are removed, the state, $D$, does not have the objects written by $A_{intrusion}$. For this reason, the sequence of tainted actions $A_{tainted}$ is empty. The set of tainted actions in the real application execution, which includes $A_{intrusion}$, would read different values and have a different execution if $A_{intrusion}$ would be empty. Therefore, if $A_{intrusion}$ and $D_{intrusion}$ are removed, then $A_{tainted}$ should be \emph{replayed} because the actions of $A_{tainted}$ are not contaminated by malicious data during their re-execution. The replay process restores the application to a correct state $D_{recovered}$, which is intrusion-free.\\

The sequence of actions, $A_{before}$, performed before the intrusion, i.e., $A_{before} = A - A_{after}$, can be extensive. Each action takes a variable but not null time to perform. Therefore, to replay $A_{recovered} : A_{before} \subseteq A_{recovered} $ may takes an excessive amount of time. We define the subsets $D_{snapshot}(t)$ and $A_{snapshot}(t) : A_{snapshot} \subseteq A$ as the subsets of object values and actions executed before the begin of a snapshot operation at instant \textit{t}. The snapshot operation copies the value of the object immediately or on the next write operation. If the attack is subsequent to $t$, then $A_{after} \cap A_{snapshot} = \emptyset \implies (A_{intrusion} \cup A_{tainted}) \cap A_{snapshot}(t) = \emptyset$, i.e., the snapshot is not affected by intrusion. For that reason, the service can replay only $A-A_{snapshot}-A_{intrusion}$ using the object set $D_{snapshot}$ as base. 


The works explained in the following sections define two distinct approaches to update the set of object $D$ to $D_{recovered}$ because of changes in the execution of $A_{tainted}$: \textit{rewind} and \textit{selective replay}. The selective replay approach loads only the previous versions of the tainted objects, $D_{tainted}$, and replays only the legitimate operations, which were tainted, $A_{tainted} \notin A_{intrusion}$, to update the objects in $D$. The $D_{legal} \notin D_{tainted}$ remain untouched. The alternative approach, rewind \cite{Brownc}, designates a process that loads a system wide snapshot previous to the intrusion moment and replays every action in $A-A_{snapshot}-A_{intrusion}$. However, this process can take a long time. \\


 A \textit{version} is a snapshot of a single object value before the instant $t$. They can be recorded with the sequence of actions that read or write them before the instant $t$. We define a \textit{compensating} action as an action that reverts the effects of a original action, for instance writing a previous value. A compensation process can obtain a previous snapshot or version. For this propose, we define the sequence $A_{compensation}(t)$ as the compensation of $A_{posteriori}(t)$, the sequence of actions after instant $t$. The compensation process applies the sequence of compensating actions $A_{compensation}(t)$ on the current version of the objects, in reverse order, to obtain a previous snapshot or version.\\

Recovery services have two distinct phases: \textit{record phase} and \textit{recovery phase}. The record phase is the service usual state where the application is running and the service records the application actions. In order to perform replay, the application actions do not need to be idempotent but their re-execution must be deterministic. The record phase should record the actions input and the value of every non-deterministic behavior to turn their re-execution into a deterministic process. The recovery phase can have three phases: determine the affected actions and/or objects, remove these effects and replay the necessary actions to recover a consistent state, as already explained in Section \ref{sec:Recovery}. The recovery services that support \textit{runtime recovery} do not require application downtime because the record and recovery phases can occur simultaneously.\\


Most of intrusion recovery services record the actions and track the objects accessed by each of them. Since the actions read and write objects from a shared set of object values $D$, we can establish dependencies between actions. Dependencies can be visualized as an \textit{action dependency graph} or an \textit{object dependency graph}. The nodes of an action dependency graph represent actions and the edges indicate dependencies though shared objects. The object dependency graph establishes dependencies between objects through actions. Dependency graphs are used to order the re-execution of actions \cite{undoForOperators}, get the sequence of actions affected by an object value change \cite{warp}, get the sequence of actions tainted by an intrusion \cite{Akkus2010} or resolve the set of objects and actions that caused the intrusion using a set of known tainted objects \cite{backtracker}. 

A \textit{taint algorithm} aims to define the tainted objects $D_{tainted}$ from a source sequence of malicious actions $A_{intrusion}$ or objects $D_{intrusion}$ using the dependency graph. The \textit{taint propagation via replay} \cite{retro} algorithm begins with the set of $D_{tainted}$ determined by the base taint algorithm and expands the set $D_{tainted}$. It restores the values of $D_{intrusion} \cup D_{tainted}$ and replays only the legal actions that output $D_{intrusion} \cup D_{tainted}$ during the original execution. Then it replays the actions dependent from $D_{intrusion} \cup D_{tainted}$, updating their output objects. While the forward actions have different input, they are also replayed and their outputs are updated.\\

Dependencies are established during the record phase or at recovery time using object and action records. The level of abstraction influences the record technique and the dependency extraction method. The abstraction level outlines the recoverable attacks. In the next paragraphs, we explain the relevant works at abstraction levels where services deployed in PaaS are attacked: operating system, database and application.\\


