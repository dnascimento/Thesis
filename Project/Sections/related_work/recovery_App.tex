%!TEX encoding = UTF-8 Unicode
\subsection{Recovery at Application Level}
\label{sec:recApp}
Web applications are the main type of application which is deployed in PaaS. These applications are usually composed of a three tier architecture: presentation tier, application-logic tier and data tier. The following works assume the data tier to be a database. 
Previous section works establish the dependencies between transactions using their read and write sets. However, they ignore the dependencies between transactions at application level. For example, an application can read a record A through a transaction 1, compute a new value B, based on A, and write the value B through a transaction 2. The application-logic tier is often state-less, the requests are independent and the database is the only mean of communication between requests (Section \ref{sec:PaaS}).\\ 


\textbf{Data Recovery for Web Applications \cite{Akkus2010}:} Goel \textit{et al.} propose a recovery service that selectively removes intrusion effects from web applications that store their persistent data in a SQL database. Since each user request may involve multiple transactions, it tracks the user, the session, the request and the accessed rows. The proposal uses a tainting algorithm and compensating transactions.

During the record phase, a monitor logs each user request and the database rows and tables read and written by the transactions associated with it. The transactions are stamped with an id that establishes the replay order, since the database uses serializable snapshot isolation.

The recovery phase is as follows. First, the administrator, using the logged data, identifies the malicious requests $A_{intrusion}$. Then, using a dependency graph, it determines the tainted requests. The dependency between transactions is established in a similar manner to the Section \ref{sec:recovery_database} but using table granularity instead of row granularity. Such coarse-grained approach may generate many false dependencies. Therefore Goel \textit{et al.} use \textit{taint propagation via replay}. More, it proposes to modify the PHP-interpreter to reduce the false dependencies between transactions using a variable-level tainting. In other words, variables that read tainted rows or fields are also tainted; rows or fields written by tainted variables are tainted. This process increases the precision of the set of tainted requests. Finally,the compensation transactions of the tainted requests are applied in reverse serialization order on the current state of the database to selectively revert the effects of the database operation issued by the tainted requests.\\ 

\textbf{POIROT \cite{poirot}:} POIROT is a service that, given a patch for a newly discovered security vulnerability in a web application code, helps administrators to detect past intrusion that exploited the vulnerability. POIROT does not recover from intrusions but proposes a tainting algorithm for application code. During the normal execution, every user request and response is stored. The log of each request includes the invoked code blocks. After the attack discover phase, the software is updated to fix its flaws. POIROT identifies the changed code blocks and requests dependent from them during the normal execution. The affected requests are replayed. During the re-execution phase, each function invocation is forked into two threads: the updated e non-updated version \cite{Wang2011}. Functions invocations are executed in parallel and their output are compared. If outputs are similar, only one execution proceeds otherwise the request execution stops since the request was affected by code patch. These concepts are used in Warp \cite{warp}.\\


\textbf{Warp \cite{warp}:} Warp is a patch based intrusion recovery service for single server web applications backed by a relational database. Unlike previous approaches, Warp allows administrators to retroactively apply security updates without tracking down the source of intrusion and supports attacks at user browser level. Warp is based on RETRO \cite{retro} \emph{taint propagation via replay} approach and removes the intrusion effects using a versioned database. The Warp prototype uses PHP and PostgreSQL. 

%normal
During the normal execution, Warp uses a client browser extension to record all JavaScript events that occur during the visit of each page. For each event, Warp records the event parameters, including the target DOM element. HTTP requests are stamped with a client ID and a visit ID to track dependencies between requests at browser level. On server side, Warp records every requests received and forwards the request to the PHP application. Since Warp uses PHP, an interpreted language, it records which files were used during the original request execution and records the non-deterministic functions. Warp stores the database queries input/output and tracks the accessed table partitions using a SQL statement parser. To conclude, the HTTP response is logged and packed with all execution records.

Warp includes a time-travel versioned relational database. Each row is identified using a row ID and includes a \textit{start time} and \textit{end time} timestamp columns that establish the row validity period. Warp reverts the intrusion effects, in a specific row, loading one of its previous versions. Warp supports concurrent repair using more two integer columns to define the begin and end of each \textit{repair generation}. At repair phase, the current repair generation ID is incremented to fork the database. User requests are performed in the current generation while recovery requests are perform in the next generation. After replaying the requests retrieved until the begin of the repairing process, the server stops and applies the remain requests.

%Como determina
During the repair phase, the administrator updates the application software to fix its flaws. Then, Warp determines the requests used the modified source code files \cite{poirot,Wang2011}. These requests are the root cause of changes during the re-execution. To update the database and reflect the patch, each user request is replay using a server-side browser and taint propagation via replay. The modified PHP interpreter intercepts non-deterministic function calls during the replay and returns the original logged value. Also, database read queries are replayed only if the set of affected rows is different or its content was modified. Write queries are replayed loading a previous version of the rows and replaying the SQL statement. Each row, which has a different result after re-execution, is now tainted and all requests that read the row are also marked to replay in the browser. Finally, the HTTP response is compared with original. If responses are different, the following dependent user interactions are replayed in the server side browser.

%Extra
The server-side browser may fail to replay the original user request. The request may depend from a reverted action of the attacker. These conflict cases are queued and handled by users later. 

%Comments 
Warp rewrites the SQL statements, which are used by the application to perform write operations in the database, adding four extra columns per table: start/end timestamp and start/end generation. However, these columns may be a considerable storage overhead. It also depends from a client browser extension to log and modify every request. Warp is designed for single machine applications: it does not support application deployed in multiple servers or distributed databases since versions are timestamp based. \\


\textbf{Aire \cite{aire}:} Aire is an intrusion recovery service for loosely coupled web services. It extends the concept of local recovery in Warp \cite{warp} tracking attacks across services. While Dare \cite{dare} aims to recover a server cluster synchronously using RETRO \cite{retro} in each node operating system, Aire performs recovery in asynchronous third-party services using Warp \cite{warp}. 

Aire prevents the recovery process from locking due to remote servers downtime. To achieve this goal, the pendent repair requests are queued until the remote server is recovered. Since clients may see a partial repaired state, Aire proposes a model based on eventual consistency \cite{Decandia2007,Vogels2009}. The model allows clients to observe the result of update operations in different orders or delayed during a period called \textit{inconsistency window}, i.e., until the remote server recovers. Aire considers the repair process as a concurrent client. To repair key-value database entries, Aire creates a new branch \cite{git} and re-applies legitimate changes. At end of local repair, Aire moves the current branch pointer to the repaired branch.

Like Warp \cite{warp}, during the normal execution, Aire records the service requests, responses and database accesses. Requests and responses exchanged between web-services, which support Aire, are identified using an unique ID to establish the dependencies.


The recovery phase is as follows. First, the administrator identifies the corrupted requests. The administrator can create, delete or replace a previous request or change a response to remove the intrusion actions. Second, Aire creates a new branch which will contain the set of changes. Third, Aire does a local repair of the application in a similar manner to Warp \cite{warp}. In contrast to Warp \cite{warp}, starts the recovery process in remote servers if at least one of the requests or responses sent previously is modified. To do so, Aire sends a request to the source or destination of the modified message. If the remote server is offline, the repair request is queued to be sent later. As repair messages propagate between the servers to start successive repairing actions, the global state of the system is repaired. However, clients may see an inconsistent state during this process. Therefore, Aire applications must support eventual consistency.  

The Aire approach using eventual consistency requires the developer to concern the conflict resolution. Moreover, Aire recovers third-party web-services which must have an Aire daemon. Aire requires the administrator to pinpoint the corrupted requests. Finally, Aire, as Dare \cite{dare}, requires application downtime during the recovery process.\\



\textbf{Undo for Operators \cite{undoForOperators}: }Undo for Operators allows the system administrators to recover from their mistakes, software problems or data corruption in email services with file system storage. The design is base on ``Three R's: Rewind, Repair and Replay" \cite{Brownc} where operator loads a system-wide snapshot previous to the intrusion, repairs the software flaws and replays the user-level requests to recover a correct application state. In contrast to the selective replay approach, where only the tainted entries are reverted, the rewind reverts all database entries. On one hand, it requires to replay more requests. On the other hand, it does not require to determine which data entries are tainted because every entry is reverted.

Undo for Operators proposes a proxy interposed between the application and its users. The proxy intercepts application requests. Since rquests most be ordered to replay, Undo for Operators defines the concept of \textit{verb}. Each protocol operation has its own \textit{verb} class. A verb object encapsulates a single interaction (request/response) of the user and exposes an interface to establish the order between requests and their dependencies. However, the proposed architecture is protocol dependent. The proxy implementation only supports IMAP and SMTP. A new protocol requires a new set of verbs. 

During the normal execution, user requests are encapsulated into verbs and sent to a remote machine: the \emph{undo manager}. The undo manager uses the interface of verbs to define its dependency, i.e., if it can be executed in parallel or must have a causal order with other request. The dependency is established per verb type depending from the operation and its arguments. Thus, the dependency mechanism is application dependent. For example, send email operations (SMTP protocol) are commutable and independent because the email delivery does not have ordering guaranties. On the other hand, the order of delete (expunge) and list (fetch) operations in the same folder is relevant and they are not independent. If two verbs are dependent, the second is delayed upon the first is processed. This method establishes a serialization ordering but it can create a significant performance overhead on concurrently arriving interactions and requires protocol knowledge.

The recovery phase strategy is as follows. First the operator determines the corrupted verbs and fixes their order adding, deleting or changing verbs. Second, the application is \textit{rewind}, i.e., a system-wide snapshot is loaded to remove any corrupted data. Third, the operator patch the software flaws of the application. Finally, all legitimate requests started after the intrusion, $A_{legitimate}$, are re-sent by the proxy to rebuild the application state. 

External inconsistencies may come out when the requests are replayed. These inconsistencies are detected comparing the re-execution and the original responses. Different responses trigger a compensating action defined per verb to keep an external consistent state. Again, these actions are application dependent.

During the recovery process, Undo for Operators replaces the current system state by a system wide snapshot. Consequently, it does not support runtime recovery. Moreover, it relies on protocol knowledge to establish dependencies, compensating actions and to sort the requests during the normal execution and recovery phase. Therefore, any protocol change requires to modify the supported verbs. Intrusions can use corrupted requests which are not defined as verb classes and cause a system fail.\\


\textbf{Summary:} Goel \textit{et al.} and Warp \cite{warp} establish dependencies using the request read/write set of the database and use taint via replay. Undo for Operators \cite{undoForOperators} establishes dependencies using the knowledge of the operations protocol. Unlike Goel \textit{et al.}, Warp \cite{warp} and Undo for Operators \cite{undoForOperators} support application repair. Warp tracks the requests affected by the modified file. Undo for Operators replays every request using its proxy. While Goel \textit{et al.} ignores external consistence, Warp \cite{warp} detects inconsistencies in responses and replays the user interaction in a browser and Undo for Operators uses compensating actions based on protocol-specific knowledge.

The approaches to remove the intrusion effects are also distinct. Goel \textit{et al.} uses compensating transactions to create a system wide snapshot, Undo for Operators loads a previous snapshot and Warp keeps the versions of each data entry. If the tainted request are few, then Goel \textit{et al.} and Warp have a significant advantage because they replay only the tainted requests. On the other hand, Undo for Operators requires less storage than the remaining options. More, the knowledge of inverse transaction is required to create the compensation of transactions. \\